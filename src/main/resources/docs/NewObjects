Objects in MethodScript allow for object oriented approaches to designing your 
code. Object in MethodScript are extremely flexible and powerful, yet easy to use 
and understand.

=== Definition vs Instance ===

An object is an instance of a class. A class is defined in code, and is used to 
define methods and members that will be in an instance of that object. A class 
can be instantiated, and get a real object out of it at runtime. You can think 
of the difference between the two as a blueprint for a house, there is only one 
blueprint, but multiple houses that are actually built, and in each house, some 
things are different, like, the paint color.

=== Example ===
Before getting into the details about objects, lets look at an average example:

<pre>
class A {

    members {
        protected @b, 
        private static int @c = 0
    }
    public A(@b = 0){
        this->@b = @b;
        @c++
    }
    
    public static int method1(int @a){
        return(@a + 1)
    }

    public method2(int @b){
        return(@b + this->@b)
    }

    public static final int instantiations(){
        return(@c)
    }
}
</pre>

This example will be used in the explanation below.

=== Members and Methods ===

An object contains any number of '''members''' and '''methods'''. A member is a 
variable, and a method is a function. Both members and variables can have various 
'''modifiers''', which affect behavior in various ways. In the example, you can 
see that we are defining @b as a member variable, and method1 and method2 
are methods. The modifiers in use include '''public''', '''static''', '''final''', 
'''int''', '''protected''' and '''private''' though there are others too. Members 
are defined in the '''member block''', <code>members{ }</code>. The member block 
may appear anywhere in the class, but there may be only one block. The rest of 
the class definition should be method definitions.

=== Basic Type Manipulation ===
Before moving on to using objects, it is important to understand the type system 
in MethodScript. All variables are ''mixed'' by default, which is actually an 
object type. All objects extend from mixed, and all user defined objects extend 
from Object. "Primitives" are in fact objects, though they are somewhat special, 
in that they are handled differently internally, but in code, they behave exactly 
like user defined objects, meaning you can dereference them to access their 
methods. If a type isn't explicitly specified when defining a variable, it is 
considered to be mixed, and any value can be put in it. Other than this caveat 
which makes MethodScript different from other strongly typed languages, it is 
otherwise a full strongly typed language, meaning types are checked at compile 
time, and invalid types will cause compiler errors. Type intersections and 
unions are discussed later, since they are an advanced topic, but they are also 
supported.

=== Instantiation ===

In order to use an object, the first thing that must happen is that it is 
instantiated. To instantiate our object that we defined above, we would use 
the following code:

<pre>
@A = new A()
</pre>

Now, we can use the '''dereference operator''' to access members or methods in 
the object, for instance,

<pre>
msg(@A->method2(2))
</pre>

would output 2, since we called the method that returns our input plus @b, 
which in this case is 0.

We can only have multiple constructors per object, but we can use default parameters, 
and static methods to reduce the number. Regardless, all the constructors must have
unique signatures, so they can be uniquely identified based on the parameters passed in.
The constructor is simply a method that is defined with the same name of the 
class, and no return type. Since there can be multiple constructors, and since you
don't need the constructor after construction, and can't get a reference an instance
before constructing it, if you need to reflectively access a constructor method, you 
must use the special reflection utilities to construct an object dynamically.

=== Dereferencing with the <code>-></code> operator ===

When you create an instance of an object, you can ''dereference'' it, that is, access
it's members and methods with the <code>-></code> operator (called the
''arrow operator''). Assuming there is a class A that has a member of type B, called
@b, and B has a member of type C, called @c, then the following example demonstrates
how to access those members.

<pre>
A @a = new A();
msg(@a->b); # Msgs out the toString for the inner @b member.
msg(@a->@b); # Also works
msg(@a->b->c); # Since @b is also an object, we can further dereference it.
</pre>

For members, after the initial reference to @a, which requires the @ sign, all
other calls to members (not methods) are allowed to leave off the @ sign. Methods
may not have an @ sign however.

Methods are dereferenced the same way as a member, except they are sent parameters
as well.

<pre>
A @a = new A();
msg(@a->myMethod());
</pre>

If you leave off the end parenthesis, this will return the method closure, so
be careful not to leave the parenthesis off if you are attempting to call the method,
because the compiler cannot catch that error for you in all cases. 

The arrow operator is not to be confused with the <code>::</code> operator, which
is used for static members and methods.

==== NullPointerException ====

If a variable that is null is dereferenced, a NullPointerException is thrown.

<pre>
A @a = null;
msg(@a->b); # Throws a NPE, because @a is null
</pre>

You may catch this exception just like any other exception.

=== Static access operator <code>::</code> ===
The <code>::</code> operator (known as the static access operator) is how you 
"dereference" a static parameter. Unlike the arrow operator, derefencing
static members and methods will never throw a NullPointerException, since
static code doesn't require an instance. In general, the usage is the same
as the arrow operator, but does allow for several advanced operations. See the
section below on Class objects and the <code>self</code> keyword.


=== Inheritance ===

An object can '''inherit''' from, or ''extend'' another object. Let's define the 
object B, which extends A.

<pre>
class B extends A {
    public B(){
        super()
    }
	@{Override}
    public method2(int @b){
        return(@b + 3)
    }
}
</pre>

In this case, we are extending A, and '''overriding''' method2. In order to 
override a method, you simply name it the same as the method in the parent 
class, and tag the method with the @{Override} annotation. 
However, it is important to note that the method signatures must be 
'''type compatible''', that is, it cannot completely redefine the types of the 
variables that are passed in, but it can use ''more specificity''. For instance, 
if class A defined the method <code>public f(Object @o)</code> it would be 
invalid to define in class B the method <code>public f(int @i)</code>, however, 
if class A instead defined f as <code>public f(mixed @o)</code>, it would be 
valid for B to '''narrow''' the type required. 

Examining the constructor, there is the new function, <code>super()</code>, 
which is used to call the parent's constructor. <code>super</code> is optional, 
however, in the case where a call to <code>super()</code> is omitted, it is 
implied to have been called at the top of the child's constructor. If 
<code>super()</code> is called, it must be called ''before'' manipulating the 
parent's members, even transiently, otherwise it is a compiler error. For 
instance, consider the following:

<pre>
class A{
    members{
        private @a
    }
    public A(){
        @a = 0
    }

    public void initA(){
        @a = 9000
    }

    public int getA(){
        if(time() % 2 == 0){
            initA()
        }
    }
}

class B{
    public B(){
        @var = getA()
        super()
    }
}
</pre>

In this example, we have a compile error, because the call to getA() could 
potentially call initA(), which manipulates @a, which is a member variable. 
The reason for this is so that the object is never in an ''inconsistent state'' 
which could occur if a subclass manipulates members of the parent before it is 
allowed to run its initialization. Had we left off the call to super, it would 
have been automatically placed at the top of the constructor, and this would not 
have been a compile error. Should a call to super() be inapplicable, because
the superclass does not define a constructor with no arguments, it is a compile
error unless each constructor in the subclass calls at least one of the superclass's
constructors with super().

=== The <code>this</code> keyword ===

TODO:

==== <code>final</code> keyword ====
The final keyword has three uses, preventing a method from being overridden,
making it impossible to subclass this class, and preventing reassignment of
a variable.

===== Preventing subclasses =====

TODO

===== Preventing overriding a method =====

TODO

===== Preventing reassignment of a variable =====
Technically this can be used outside of classes, so the following is applicable
anywhere in code:

<pre>
final string @s = '';
@s = 'new string'; # Compiler error
</pre>

When a member variable is tagged as final though, it has slightly different
usage. When object construction is complete, all final variables must have
had some value assigned to them. That is, all code branches must lead to
the value being assigned. During construction ONLY, the value may be changed
multiple times however, and in fact, this allows for final variables to be assigned
a default, and still be changed. (If it's meant to be an actual constant, you should
make the variable static anyways, so it doesn't incur extra overhead per instance.)

==== Constructors ====

Constructors look sort of like methods but they are special, because you may define
multiple constructors in each class. As long as each constructor has a completely
different ''type erasure'' it is allowed. For instance, the following is allowable:

<pre>
class A {
	
	public A(){

	}

	public A(string @v){

	}
}

A @a1 = new A(); # Uses the first constructor
A @a2 = new A(''); # Uses the second constructor
</pre>

Inside of a constructor, you may make calls to <code>super()</code>, which calls
the applicable super class's constructor. It is required for each constructor to call
at least one of the super class's constructors (though if a no-arg constructor is available,
it will automatically be called). Additionally, a call to this() will
call this class's applicable constructor, and may be called at any point in the
constructor, since final variables are still manipulable at this point. As an advanced
example:

<pre>
class A {
	members {
		public final @var = 1
	}

	public A(){
		@var = 2;
	}

	public B(){
		this();
		@var = 3;
	}
}
</pre>

Unlike instance methods, super class constructors are not exposed by default. If
a class does not have any final variables though, it can easily expose them individually,
using the <code>inherit</code> keyword.

<pre>
class A {
	public A(string @var){
		# ...
	}
}

class B {
	inherit A(string @var); # The signature must be the exact same as the superclass's
}
</pre>

If you declare the constructor this way, it is exactly the same as if we did this:

<pre>
class B {
	public B(string @var) {
		super(@var);
	}
}
</pre>

That is, usage of both would be the same:

<pre>
B @b = new B('');
</pre>

Abstract constructors are also allowed in abstract classes. The section on abstract
classes covers this.

===== Default Constructors =====

If zero constructors are provided, a default constructor is always provided, with 
the definition <code>public A(){ }</code> (assuming the class name is A).

==== Destructors ====

A destructor is automatically called when an object goes out of scope, and can 
be used to do various things. It is never required to implement, however. It is 
implemented in a '''destructor block''', much like member blocks.

<pre>
class A{
    members{
        private static int @instances = 0
    }

    public static int totalInstances(){
        return(@instances)
    }

    public A(){
        @instances++
    }

    destructor{
        @instances--
    }
}
</pre>


=== Static members and methods ===
You may have noticed that the keyword '''static''' has been used a few times.
A ''static'' variable is one that is usable outside of any instances, often times
utility methods, singletons, and factory methods are defined this way. A static
method can be accessed as such:

<pre>
class A {
	public static void init(){
		return()
	}
}

#Usage:
A::init()
</pre>

You do not need to instantiate a class before using a static method. Since a static
method is essentially a convenient way to namespace a method, or otherwise
associate it with similar non-static code and it isn't ''really'' part of the class,
it is not possible to call a static method by dereferencing an instance. If you are creating
a pure utility class, that only has methods (no members), then consider using
a namespace instead.

==== <code>Class</code> objects, and <code>self</code> keyword ====
The <code>Class</code> class is a meta object, which represents a class. The class
object is actually what you use when you call a static method: <code>A::staticMethod()</code>
Because the Class object is first class, and a special object however, you can assign
it to a Class object variable, and use it dynamically. The Class object relies heavily
on Generics though, so you should be familiar with them first. Consider the following two classes.

<pre>
class A {
	public static int value(){
		return(2);
	}
}

class B extends A {
	@{Override}
	public static int value(){
		return(3);
	}
}

# The obvious usage:
msg(A::value()) # 2
msg(B::value()) # 3
</pre>


<pre>
Class<? extends A> @class = A;
# Now we can do this, because we know that @class is at least
# A or a subclass
msg(@class::value()); # returns 2

@class = B;
msg(@class::value()); # returns 3
</pre>

Often times though, when making factory classes, you end up having to instantiate
an object, just to call the subclass's methods that were defined as instance
variables, just so you can enforce a particular method on a subclass. The 
<code>self</code> keyword is of type Class<? extends CurrentClass>, and is a reference
to the runtime Class type of the variable. So, the following
allows for variable static methods to be called, from within the superclass:

<pre>
class A {
	public static void test(){
		msg(A::value());	# Will always say "Called from A" 
		msg(self::value()); # Unknown at this time, see below for results
	}

	public static string value(){
		return('Called from A');
	}
}

class B {
	@{Override}
	public static string value(){
		return('Called from B');
	}
}

A::test(); # This messages "Called from A" twice
B::test(); # This messages "Called from A", then "Called from B"

Class<? extends A> @class = A;
@class::test(); # "Called from A" twice
@class = B;
@class::test(); # "Called from A", then "Called from B"
</pre>

As you can see, the currently scoped Class object is what <code>self</code>
refers to, which is not necessarily the class it is defined in. It is worth
noting that if a static method is called without a classifier, it is assumed
to be prefixed with <code>self</code>. Static methods can therefore be abstract
or final, which allows them to be used like instance methods of the Class object.

=== Access Modifiers ===
'''public''', '''private''', and '''protected''' are the three modifiers that 
control what can access an object's methods or members. If something is public, 
anything can access it. If it is private, only that class can access it, and if 
it is protected, only that class, or subclasses can access it.

=== Explicit namespacing ===
In an instance, we can always using explicit namespacing to reference a parent's 
methods. If we are in a static context, it will be a compiler error to reference 
instance methods in this manner, but static references are always valid. For 
instance, assume class B had been defined this way:

<pre>
class B extends A {
    public B(){
        A::super()
    }
    public method2(int @b){
        return(A::super->method2(@b))
    }
}
</pre>

Note that we are explicitely calling A's constructor with the call to super, 
and A's method2. If there had been several parents, this could be used to 
"un-override" a call, or otherwise explicitely selected a method that had been 
overriden by multiple children. This is useful outside of diamond inheritance, 
but is more often used when dealing with multiple inheritance. Note that in the 
case of super() constructors, it is always an error to cause a child's 
constructor to be invoked before the parent's constructor. Calling a parent's
method is only valid inside the class, an overridden method is not callable
from outside of the instance.

=== Reflection ===
Using reflection, you are able to access all members and methods reflectively, 
using simple, array-like notation. Using reflection bypasses the safeguards put 
in place with public/private/protected accesses though, which may be desired, 
but should be used with caution, since it violates the object's contract of 
access. All objects implement the ability to get, set, and enumerate all the 
members and methods in it, using string based names. New members and even methods 
can be added to an object at runtime by using this mechanism. Compilation type 
checks obviously won't apply, so things that normally would be a compile error 
will be runtime errors, so code that uses reflection must be very careful. 
Consider our class A, defined above, and instantiated as such:

<pre>
@a = new A()
</pre>

We can access both the protected and private static variables in the class by 
using the following code:

<pre>
msg(@a['A::b'])
msg(@a['c'])
</pre>

If you do not fully qualify a variable name, it is automatically qualified with
that instance's actual runtime type. So unless you want to actually get a type's
method without caring precisely which method it will be, consider always fully
qualifying the variable name. (@a['A::b'] vs @a['b'])

We can change existing variables (or add new ones) with:

<pre>
@a['A::b'] = 5
@a['A::c'] = 10
@a['A::d'] = proc(@a, @b){ return(@a + @b) } #Add a new method
</pre>

If a variable is added with reflection, it will obviously only be 
accessible through reflection, and it only becomes part of that instance. 
Changes to static variables or methods and constructors are not possible, 
because static variables are not actually a part of that instance,
and constructors do not behave like normal methods. 
You must use the class reflection methods to manipulate those. The array 
notation is merely a convenience, using this notation simply hides the 
complexity of getting and setting static and instance variables reflectively. 
You can iterate through the variables using foreach, and array_keys will work 
as well. As you can see, for this reason, a member and a method cannot share 
the same name in a class. It is also important to note that variables are 
prefixed with the class name, because a parent's variables are also available. 
In the case of inherited variables, the child class will not have a variable in 
the array, even though calling the method non-reflectively would work.

This mechanism of reflection is useful for setting and getting variables in an 
''instance'', but if you are interested in information about the Class itself 
(not an instance of it, or you are interested in static variables), or you wish
to manipulate the constructors,
you can use the functions that are provided in the reflection namespace.


=== Interfaces ===

TODO

=== Abstract Classes ===

TODO

=== <code>@{Override}</code> annotation ===

The <code>@{Override}</code> annotation is required on all methods that override
either a superclass or interface's methods. This prevents an interface or super
class from changing without the subclass being explicitly aware of the change.
This property allows for better code maintenance, and encourages use of the
[http://en.wikipedia.org/wiki/Open/closed_principle open/closed principle].
If a method overrides a superclass or implements an interface method, it must
have this annotation, or it is a compile error.

If this compile error appears in other classes later in your development, you
will be immediately aware of all places where other code is affected, and you can
properly account for those changes, or remove dead code, if a method is removed.
This allows you to quickly determine how much of an impact (and what can be impacted)
by the given code changes.

=== Multiple Inheritance ===

TODO

==== <code>inherit</code> keyword ====

Though default inheritance would work in singly inherited classes, it is really
only useful when dealing with multiple inheritance. In the case where multiple
objects are inherited from, and each defines their own version of a method,
it may be useful to inherit the method's behavior from the non-primary inherited
class. One way to do this would be to override the method yourself, and simply
delegate behavior to the correct super class's method, for instance:

<pre>
class A {
	public mixed method(){
		return(1)
	}
}

class B {
	public mixed method(){
		return(2)
	}
}
class C extends A, B {
	public mixed method(){
		return(B::method())
	}
}
</pre>

However, since this could occur fairly often, you may simply indicate that you
would like to ''inherit'' functionality from the specified parent. So instead
of defining the class C as above, we can get the exact same functionality by
defining it as such:

<pre>
class C extends A, B {
	inherit B::method()
}
</pre>

By default, methods with multiple overrides in parent classes inherit from the
primary parent, in this case, A, though you can also be explicit and inherit a
method individually.

=== Type Unions ===

A type union (or disjoint types) can be used any time disjoint types are required. Assume the following
hierarchy:

<pre>
class A { }
class B extends A { }
class C extends A { }
class D extends B { }
</pre>

Now, assume that we want to accept an instance of either type D or type C, but not
type B or A. In this case, the nearest parent is type A, so we could accept type A and
do a runtime check to ensure that it is of type D or C only, but this is a runtime
check, and it would be better if we could simply declare that we only want those
two types. In that case, we can use a '''type union''' to signal to the compiler
the various types we will accept. To specify a type union, use the 
'''<nowiki>|</nowiki>''' character.

<pre>
D | C @var
</pre>

As many types as required can be chained this way. As far as the inferred type of
that object, it will be whatever the nearest '''type intersection''' is. So, in this
case, the code using the variable @var must assume that it is of type A, unless it
does an explicit cast first. So, as far as code that ''uses'' the variable, it will
work as if it were defined as <code>A @var</code>, but with the guarantee that only
a D or C type instance will have been assigned to it.

When using disjoint types, variable Class objects may also be used, and it is as if
the class is highest superclass defined for it.

<pre>
Class<? extends B> @class1 = D;
Class<? extends A> @disjoinClass = A | @class1; 
</pre>

In the second line, it is actually irrelevant that D is stored in @class1, B is
assumed, so that is the same as <code>A | B</code>. 

When using disjoint types, a value of Class<?> is required, so if @class1 were typed as 
auto, then @class1 would be assumed to be typed as Class<Mixed>, thereby making
that a pointless operation. Therefore, if using auto types in combination with
disjoint types, this will be a compiler error. The pipe operator is shorthand
for the {{function|disjoint_type}} function.

=== <code>immutable</code> keyword ===

A class can be marked as immutable, which allows for better optimizations, and
better compile time guarantees. If a class is marked as immutable, all data
members are implicitly marked as immutable, and it can be used as a data member
in other classes that are immutable, or explicitly marked as an immutable data
member.

If a class is marked as immutable, it is guaranteed at compile time that the data
members are not changed, except during construction. This guarantee applies recursively
to all data members as well. For arrays (and therefore maps and Objects) this means
that no more elements can be added or changed once construction is complete. Additionally,
none of the data members in the class can be marked as static.

Immutable objects work closely with various language features, from causing better
compiler errors when unintentional programming occurs, to better optimization 
potential, to more efficient serialization, to more efficient and accurate cross process
object transfer. All primitives are implied immutable, except arrays are a special case, 
which know to natively support immutability, only if they are marked
as an immutable data member. All user data types must explicitly mark themselves as
immutable if they intend to be used as an immutable data member in other classes.

If the class is marked as immutable, all data members are marked as immutable, and
it may be used in another composite class as a data member itself.
<pre>
	immutable class A {
		members{
			private int @a;
			private int @b;
			private array @c;
		}
		
		public A(){
			@a = 5;
			@b = 2;
			@c = array(1, 2, 3);
		}

		public setA(int @i){
			#This causes a compile error
			@a = @i;
		}
	}
</pre>

Additionally, individual data members can be marked as immutable, which confers
no immutability on the object as a whole, but allows for a few of the advantages
that marking the whole class as immutable provides. When marking data members that
have an immutable type already, this makes them work like "final" data members in
Java, that is the reference cannot change, and when marking arrays as immutable,
makes their internal structure immutable, as well as preventing the reference
from changing.
<pre>
class B {
	members{
		public int @i;
		public immutable array @a;
		public immutable int @b;
	}

	public B(){
		@i = 2;
		@a = array(1, 2, 3);
		@b = 5;
	}

	public setI(int @val){
		@i = @val; #Valid
	}

	public setArray(array @val){
		#Compile error
		@a = @val;
	}

	public pushArray(mixed @val){
		#Compile error
		array_push(@a, @val);
	}

	public setB(int @val){
		#Compile error
		@b = @val;
	}
}
</pre>

=== Inner classes ===

Classes themselves may be defined inside other classes as well. There are two
types of inner classes, static and non-static. Static inner classes are the
easiest to understand, so that will be covered first.

==== <code>static</code> inner classes ====

When we create a static inner class, it is essentially a way to namespace another
class. Common sense dictates that the two classes should be closely related, but
they are otherwise completely independent of each other. We define the class like normal,
but using the <code>static</code> keyword.

<pre>
class Outer {
	public static class Inner {

	}
}
</pre>

By convention, inner class definitions appear at the bottom of the outer class, but
can be declared anywhere directly inside of the outer class. When we create a new
class this way, we construct it the same as the outer class, but we must qualify it
as if the outer class were part of the namespace.

<pre>
Outer::Inner @c = new Outer::Inner();
</pre>

Beyond this, the inner class will behave just as any other outer class would, assuming
it is public. If the class itself is defined as protected or private, it is only available
to subclasses, or just this class, respectively. From within the outer class (or a subclass of
that), it is not needed to fully qualify the name of the class, so simply writing the inner class
name will work.

<pre>
# From inside of Outer
Inner @c = new Inner();
</pre>

Inner static classes have access to all of their parent's static members and methods, unlike
outer classes, so the following code is acceptable:

<pre>
class Outer {
	private static String Method(){
		return('string');
	}

	static class Inner {
		public static GetString(){
			# This refers to the outer class's method
			return Method();
		}
	}
}
</pre>

==== Non-static inner classes ====

Unlike static inner classes, a non-static inner class is associated with an instance of
the outer class. This means that a new instance cannot be constructed without an instance of
the outer class, though the inner class can access the outer class's non-static members.

<pre>
class Outer {
	members {
		public int @i = 2;
		public Inner @inner = new Inner(); # From here, we can construct a new Inner class
	}
	public class Inner { # Note the lack of the static keyword
		public GetI(){
			return(@i);
		}
	}
}
</pre>

Notice the creation of the Inner class in the outer class's members. This works
because that member will be initialized upon construction of the object, at which
point an instance will obviously exist. When constructed from outside of the class
however, we must qualify it with an instance.

<pre>
Outer @outer = new Outer();
Inner @inner = new @outer->Inner();
</pre>

Because this works like a member or method, we cannot have both an inner class and
a method/member named the same.

When running inside of the inner class, the <code>this</code> keyword refers to the outer
class, but you can access the inner class's "this" pointer by using a special notation.
Consider the following example, where there is an @i member in both the outer and inner
class.

<pre>
class Outer {
	members {
		public int @i = 2;
	}
	public class Inner {
		members {
			public int @i = 3;
		}
		public print(){
			msg('Outer class\'s @i: '.@i);					# 2
			msg('Also the outer class\'s @i: '.this->i);	# 2
			msg('Inner class\'s @i: '.Inner->this->i);		# 3
		}
	}
}
</pre>
{{LearningTrail}}